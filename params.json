{"name":"ko-filteredOptions","tagline":"A custom Knockout binding based on the 'options' binding: it allows to filter certain items of a bound collection, keeping them from being attached to the <select> control.","body":"## Introduction\r\nThis is a quite simple custom Knockout binding that I implemented due to a particular need I had with the project my colleague @codecoding and I were working on at the time.\r\n\r\nWe had a series of `<select>` controls the sources of which would be retrieved from server on page load through AJAX requests, and then populated through the use of observable arrays and the _options_ binding. These controls were part of a form that was, in turn, also data-bound to a viewmodel.\r\n\r\nFor some reason we needed that, at some point, some of the `<option>` elements in our `<select>` controls could be hidden, filtered out, so that they could not be selected. Removing these `<option>` elements by removing the respective objects from their bound data-source was not an acceptable solution: our data-sources had to remain unchanged. Since these \"particular options\" had to be filtered according to a certain property's value in the source collection's objects, we came up with the idea for our own custom _options_ binding.\r\n\r\n## So, what does it do?\r\nIt's probably easier to understand with an example so here it goes. We define to viewmodels, _Attendee_ and _Show_.\r\n```javascript\r\nvar Attendee = function (name, show) {\r\n  this.Name = ko.observable(name ? name : '');\r\n  this.SelectedShow = ko.observable(show ? show : null);\r\n};\r\n\r\nvar Show = function(name, isAvailable) {\r\n  this.Id = ko.observable();\r\n  this.Name = ko.observable(name ? name : '');\r\n  this.IsAvailable = ko.observable(isAvailable ? isAvailable : false);\r\n};\r\n```\r\nAs you can see, when instantiating an _Attendee_ we must specify the attendees's name and, optionally, a show identifier. In turn, when instantiating a _Show_ we must specify its name and whether it is available or not. Next we define a collection of _Attendees_ and a collection of _Shows_. \r\n\r\n```javascript\r\nthis.Attendees = ko.observableArray([\r\n  new Attendee('John', 1),\r\n  new Attendee('Paul', 2),\r\n  new Attendee('George', 3),\r\n  new Attendee('Ringo', 4)\r\n]);\r\n\t\r\nthis.Shows = ko.observableArray([\r\n  new Show('Grease', true),\r\n  new Show('Mamma mia!', true),\r\n  new Show('The phantom of the opera', true),\r\n  new Show('We will rock you', true)\r\n]);\r\n```\r\nNow, as you may have already imagined, our intention is to pair each _Attendee_ with a _Show_. The collection of shows available to the attendees will be filtered according to whether or not the _Show_'s property `IsAvailable` is set to `true`. Head to [this fiddle](http://jsfiddle.net/pchiwan/z7EYc/) to see it working. Here's the snippet of html code where you can see the our custom data binding _filteredOptions_.\r\n```html\r\n<div class=\"example2\">\r\n  <div class=\"left\">\r\n    <!-- ko foreach: { data: Attendees(), as: 'attendee' } -->\r\n    <div class=\"attendee\"> \r\n      <b>Attendee: </b><span data-bind=\"text: attendee.Name\"></span><br>\t\r\n      <b>Selected show: </b><select data-bind=\"filteredOptions: $root.Shows, optionsFiltering: { propertyName: 'IsAvailable', propertyValue: false }, optionsValue: 'Id', optionsText: 'Name', optionsCaption: 'Choose a show', value: attendee.SelectedShow\"></select>\r\n    </div>\r\n    <!-- /ko -->\r\n  </div>\r\n  <div class=\"right\">\r\n    <!-- ko foreach: { data: Shows(), as: 'show' } -->\r\n    <div class=\"show\">\t\r\n      <b>Show: </b><span data-bind=\"text: show.Name\"></span><br>\t\r\n      <b>Is available? </b><input type=\"checkbox\" data-bind=\"checked: show.IsAvailable\"></input>\r\n    </div>\r\n    <!-- /ko -->\r\n  </div>\r\n</div>\r\n```\r\n\r\n## How does it work?\r\nBasically I copied the code of the original _options_ binding and enhanced it by adding the tiny snippet of logic that does our magic trick. And the trick consists in evaluating a certain property in the source collection's objects and, depending on this property's value, keep these objects from being appended as `<option>` elements to the `<select>` control or not.\r\n\r\nThe only drawback is that we also had to copy some Knockout's private utility methods in order to expose them (because they are not exposed in the production version).\r\n\r\n## Before we get into detail...\r\nFollowing up on the previous example fiddle, imagine this situation: we have a collection of _Attendee_, we select a _Show_ for each of them, and save the form. Assuming there is a stock of available tickets for each _Show_, when a _Show_ is sold out we should mark it as not available by setting `IsAvailable` to `false`. \r\n\r\nDoing this will trigger an update in the _filteredOptions_ data binding, causing the source to be re-evaluated and, therefore, the `<option>` elements to be first removed from and then re-attached to their respective data-bound `<select>` controls. Thus, a _Show_ that had been previously selected for an _Attendee_ before becoming unavailable will suddenly disappear from the data-bound `<select>` control's available options; in short: the _Show_ is no longer a selectable option to any of the _Attendee_, even those who had selected the _Show_ when it was still available. And that's not ok!\r\n\r\nI worked around this issue thanks to a very simple but very powerful Knockout extender implemented by my colleague @codecoding, so the credit for the following snippet of code goes to him.\r\n```javascript\r\nko.extenders.track = function (target, doTrack) {\r\n  //<summary>Will track property changes</summary>\r\n  //<param name=\"target\" type=\"Object\">The observable</param>\r\n  //<param name=\"doTrack\" type=\"boolean\">true to track the observable, false otherwise</param>\r\n  \r\n  if (doTrack) {\r\n    target.isTracked = true;\r\n    //keep the observable's original value\r\n    target.originalValue = target();\r\n    //in order to keep track of whether the observable is modified or not\r\n    target.subscribe(function(newValue) {\r\n      if (newValue == target.originalValue) {\r\n        target.modified = false;\r\n      } else {\r\n        target.modified = true;\r\n      }\r\n    });\r\n  } else {\r\n    target.isTracked = false;\r\n  }\r\n  return target;\r\n};\r\n```\r\nThis extender allows us to keep track of the original value of an observable. Let's apply it to our current example; here's how we modify the definition of our _Attendee_ viewmodel by including the tracking extender.\r\n```javascript\r\nvar Attendee = function (name, show) {\r\n  this.Name = ko.observable(name ? name : '');\r\n  this.SelectedShow = ko.observable(show ? show : null).extend({ track: true });\r\n};\r\n```\r\nNow, when declaring our collection of attendees, we pass in an initial value -a show id- when instantiating each _Attendee_. The updated fiddle to try this out is [here](http://jsfiddle.net/pchiwan/R8AKP/).\r\n```javascript\r\nthis.Attendees = ko.observableArray([\r\n  new Attendee('John', 1),\r\n  new Attendee('Paul', 2),\r\n  new Attendee('George', 3),\r\n  new Attendee('Ringo', 4)\r\n]);\r\n```\r\nWe also need to update the markup accordingly: we must add another parameter to the _filteredOptions_ data binding.\r\n```html\r\n<select data-bind=\"filteredOptions: $root.Shows, optionsFiltering: { propertyName: 'IsAvailable', propertyValue: false, exceptionValue: attendee.SelectedShow.originalValue }, optionsValue: 'Id', optionsText: 'Name', optionsCaption: 'Choose a show', value: attendee.SelectedShow\"></select>\r\n```\r\nAs you can see for yourself in the fiddle, when making a _Show_ unavailable, the corresponding `<option>` will disappear from every `<select>` control except for those which had that `<option>` selected from the very beginning. We achieve this through the use of the _tracked_ extender, along with the parameter `exceptionValue`. Keep reading to learn...\r\n\r\n## How do I use it?\r\nYou must use the _filteredOptions_ data binding instead of the original _options_ binding. Keep in mind, though, that in order for our data binding to work, the data source must necessarily be a collection of JavaScript objects, a collection of strings won't do! \r\nSo the parameters we'll be using are those of the _options_ binding, plus a few more we've added. The examples provided are related to the previously referenced fiddle.\r\n* **propertyName**. \r\n\r\nIndicates the name of the property in the source collection's objects that will be evaluated to determine whether or not they must be attached to the `<select>` control. It must be written between single quotes. I.e.: `propertyName: 'IsAvailable'`.\r\n\r\n* **propertyValue**. \r\n\r\nIndicates which value should the specified `propertyName` have in order for the object to be kept from being attached as an `<option>` to the `<select>` control. I.e.: `propertyValue: false`.\r\n\r\n* **exceptionValue**. \r\n\r\nI.e.: `exceptionValue: attendee.SelectedShow.originalValue`.\r\n\r\n## Another example\r\nHere's another usage example, the fiddle for which you will find [here](http://jsfiddle.net/pchiwan/c55g2/). We start by defining, again, two viewmodels: _Guest_ and _Meal_.\r\n```javascript\r\nvar Guest = function (name, isVegan) {\t\r\n  this.Name = ko.observable(name ? name : '');\r\n  this.IsVegan = ko.observable(isVegan ? isVegan : false);\r\n  this.SelectedMeal = ko.observable();\r\n};\r\n\r\nvar Meal function = (name, isApt) {\r\n  this.Id = ko.observable();\r\n  this.Name = ko.observable(name ? name : '');\r\n  this.IsAptForVegans = ko.observable(isApt ? isApt : false);\r\n}\r\n```\r\nAs you can see, when instantiating a _Guest_ we must specify the guest's name and whether he/she is vegan or not. In turn, when instantiating a _Meal_ we must specify its name and whether it is apt for vegans or not. Next we define a collection of _Guests_ and a collection of _Meals_. \r\n```javascript\r\nthis.Guests = ko.observableArray([\r\n  new Guest('Ernie', false),\r\n  new Guest('Bert', false),\r\n  new Guest('Cookie monster', true)\t\t\r\n]);\r\n\t\r\nthis.Meals = ko.observableArray([\r\n  new Meal('Pepperoni pizza', false),\r\n  new Meal('Chicken fingers', false),\r\n  new Meal('Chocolate cookies', true),\r\n  new Meal('Cheese burger', false),\r\n  new Meal('Fruit salad', true)\r\n]);\r\n```\r\n\r\nSee the html code below.\r\n```html\r\n<!-- ko foreach: { data: Guests(), as: 'guest' } -->\r\n<div class=\"guest\">\r\n  <div class=\"left\">\r\n    <b>Guest: </b><span data-bind=\"text: guest.Name\"></span><br>\r\n    <b>Is vegan? </b><input type=\"checkbox\" data-bind=\"checked: guest.IsVegan\"></input>\r\n  </div>\r\n  <div class=\"right\">\r\n    <span><b>Meal of choice:</b></span><br>\r\n    <select data-bind=\"filteredOptions: $root.Meals, optionsFiltering: { propertyName: 'IsAptForVegans', propertyValue: !guest.IsVegan() }, optionsValue: 'Id', optionsText: 'Name', optionsCaption: 'Choose a meal', value: guest.SelectedMeal\"></select>\r\n  </div>\r\n</div>\r\n<!-- /ko -->\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}